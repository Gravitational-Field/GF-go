# 1. go语言介绍

## 1.1 go的由来

> Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。

## 1.2 go的特性

> - 自动垃圾回收
> - 更丰富的内置类型
> - 函数多返回值
> - 错误处理
> - 匿名函数和闭包
> - 类型和接口
> - 并发编程
> - 反射
> - 语言交互性

## 1.3 go代码案例解读

> - 包声明
> - 引入包
> - 函数
> - 变量
> - 语句 & 表达式
> - 注释

```go
package main 

import "fmt"  
func main() { 
   /* Always Hello, World! */
   fmt.Println("Hello, World!")
}
```

- **解析:**

1.  package main定义了包名。**（必须在源文件中非注释的第一行指明这个文件属于哪个包）。**在go应用（一系列go文件及其它文件）的main包中，开始运行，故每个 Go 应用程序都包含一个名为 main 的包。

2.  import "fmt"告诉编译器程序运行需要用fmt包。fmt 包实现了格式化 IO（输入/输出）的函数。

3.  func main() 是程序开始执行的函数，main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数  **（如果有 init() 函数则会先执行该函数）**。

4.  **{}中"{"不可以单独放一行。**

5.  注释： 

    - // 单行注释      

    - /* 块注释（ 多行注释） 不可以嵌套使用，一般用于包的文档描述或注释成块的代码片段。*/   

6.  fmt.Println(...) 将字符串输出到控制台，并在最后自动增加换行字符 \n。等价于 fmt.Print("hello, world\n") 。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。

## 1.4 go语言编译与执行

- 编写hello.go（复制上边的文本）

```go
go run hello.go   //编译并运行

go build hello.go //编译生成二进制文件
./hello  // 再进行运行
```

# 2. go环境配置

## 2.1 IDE选择

> IDE需知：vscode与goland，推荐使用vscode，vscode免费，goland收费。
>
> vscode地址：https://code.visualstudio.com/
>
> goland地址：[https://www.jetbrains.com/go/](https://www.jetbrains.com/go/)

## 2.2 go安装包

> 下载地址：
>
> 1. [https://golang.org/](https://golang.org/)    
> 2. [Go下载 - Go语言中文网 - Golang中文社区 (studygolang.com)](https://studygolang.com/dl)

## 2.3 go配置

> - 不管是哪个系统，需要配置go安装环境到path环境变量里面。   **go/bin目录添加到path中**
> - goland只需要选择go对应的sdk配置即可，也就是把go安装的路径添加进去，使用安装的go环境进行编译，不需要安装任何额外插件。
> - vscode需要安装额外插件，在插件市场里面直接搜索go，随后进行安装即可。在安装的时候容易出现下载失败问题，此时需要更换为国内源，如下设置：

```go
windows设置：
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
```

```go
MacOS or Linux
export GO111MODULE=on
export GOPROXY=https://goproxy.cn
```

![image-20201214203851365](https://cdn.jsdelivr.net/gh/lizhangjie316/img/2020/20201216191625.png)

---

# 3. 数据类型、关键字、标识符

## 3.1 基本数据类型

> 代码：go-code/01_datetype.go

### 3.1.0 bool类型

```go
/*bool类型测试*/
	var b bool = false
	fmt.Println(b)
```

### 3.1.1 常量和变量

```go
/*变量*/
	//普通赋值
	var num int = 1
	fmt.Println(num) //1
	//平均赋值
	var num1,num2 = 2,3
	fmt.Println(num1,num2) //2 3
	//平行赋值
	var (
		num3 int= 3
		num4 int = 4
	)
	fmt.Println(num3,num4) //3 4
```

### 3.1.2 整数类型

```go
/*整数类型*/
	var num8 int8= 027  // 23
	fmt.Println(num8) //按十进制进行输出
	var num16 = 0x39 //57
	fmt.Println(num16) //按十进制进行输出
```

### 3.1.3 浮点数类型

```go
/*浮点数*/
	var floatnum float32 = 58.3e-2
	fmt.Println(floatnum) //0.583
	num = int(floatnum) //float32转int64
	fmt.Println(num) //0
```

### 3.1.4 复数类型

```go
/*复数类型测试*/
	//var x float32= 10.0
	//var y float32= 13.0
	// cannot use complex(x, y) (type complex64) as type complex128 in assignment
	//64位的复数，需要64位的float，不能是其它类型
	var x float64= 10.0
	var y float64= 13.0
	var name complex128 = complex(x, y)

	fmt.Println(name) //(10+13i)
	var z complex128 = name
	fmt.Println(z) //(10+13i)
	fmt.Println(real(name)) //10
	fmt.Println(imag(name)) //13
	fmt.Println(name == z) //true
```



### 3.1.5 别名类型

> Unicode 字符的 rune 类型和 int32 类型是等价的，通常用于表示一个 Unicode 码点，是等价的。
>
> byte 和 uint8 也是等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数。

```go
/*别名类型byte和rune*/
	//byte == uint8
	//var b1 byte = 256 //constant 256 overflows byte
	var b1 byte = 255 //constant 256 overflows byte
	fmt.Println(b1) //255

	//rune == int32   与Unicode编码对应
	//var r1 rune = math.MaxInt32 + 1 //constant 2147483648 overflows rune
	var r1 rune = math.MaxInt32 //2147483647
	fmt.Println(r1)
	var r2 rune = 'A'
	fmt.Println(r2) //65   输出了A字符代表的Unicode编码号
```



### 3.1.6 字符串类型

```go
/*字符串类型*/
	var str1 string = `hello\nabc`  //原生表示法   反引号  在左上角而非 单引号
	var str2 string = "world\nabc"  //解释性表示法  会对转义字符进行解释
	fmt.Println(str1+str2)  //hello\nabcworld
							//abc
```



### 3.1.7 数组类型

```go
/*数组类型*/
	//长度确定
	type nums1 [3]int //只是声明一个[3]int的数组
	//fmt.Println(nums1) //Type nums1 is not an expression
	var nums2 = [3]int{1,2,3}  //起别名     PS:起别名时无需指定类型
	var nums3 = [...]int{1,2,3,4,5}  //起别名
	fmt.Println(nums2)  //[1 2 3]
	fmt.Println(nums3)  //[1 2 3 4 5]
	fmt.Println(nums3[2])  //3
	//修改nums3中的值
	nums3[2] = 9
	fmt.Println(nums3) //[1 2 9 4 5]
	var length = len(nums3)   //PS:起别名时无需指定类型
	fmt.Println(length) //5
```



### 3.1.8 切片类型

```go
/*切片类型*/
	//属于引用类型，长度不确定，底层用数组
	type sliceInt []int //声明的作用？
	s := sliceInt{1, 2, 3} //[1 2 3]   :=是什么操作？
	fmt.Println(s)
	var sliceInt1 = []int{4,5,6,7,8,9}  //[4 5 6 7 8 9]
	fmt.Println(sliceInt1)
	//切片
	var slice1 = sliceInt1[1:4]  //[5 6 7]  前闭后开，类似于python
	fmt.Println(slice1)
	//切片的长度与容量：一个切片值的容量即为它的第一个元素值在其底层数组中的索引值与该数组长度的差值的绝对值
	fmt.Println(len(s)) //3
	fmt.Println(len(sliceInt1)) //6
	fmt.Println(len(slice1)) //3
	fmt.Println(cap(s)) //3
	fmt.Println(cap(sliceInt1)) //6
	fmt.Println(cap(slice1)) //5     [5,6,7,8,9]
	//切片值的改变会影响切片原始的值
	slice1[0] = 100
	fmt.Println(sliceInt1)  //[4 100 6 7 8 9]
	//通过切片的第三个值进行限制切片的访问
	var slice2 = sliceInt1[0:2:3]  //3
	fmt.Println(cap(slice2))
	//延展切片
	fmt.Println(slice1[:5])  //原本slice1的值为[5 6 7] 现在输出  [100 6 7 8 9]  意为延展其长度为5，数据参照slice1从哪里切过来的，就从哪里可以观察到   这个5是cap(slice1)
	//在切片中加入第三个索引后， var slice1 = numbers3[1:4:4] 将无法通过slice1访问到number3的值中的第五个元素。
	//使用内建函数append可以不受限制的扩展,并返回一个新的切片值,与
	fmt.Println(slice1) //[100 6 7]
	var slice3 = append(slice1, 40,41,42)
	fmt.Println(sliceInt1) // [4 100 6 7 8 9]  与最初是的切片值的来源将没有关系
	fmt.Println(slice3) //[100 6 7 40 41 42]

	//copy函数会直接对其第一个参数值进行对应位置的修改
	var slice4 = []int{0, 0, 0, 0, 0, 0, 0, 0}

	fmt.Println(copy(slice4,slice1)) //3   意为替换了3个
	fmt.Println(slice4)  //[100 6 7 0 0 0 0 0]
```



### 3.1.9 字典类型



### 3.1.10 通道类型



### 3.1.11 注意

> 1. 无符号的整数类型 uintptr，它没有指定具体的 bit 大小但是足以容纳指针。只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。
> 2. **有符号整数采用 2 的补码形式表示**，也就是最高 bit 位用来表示符号位，一个 n-bit 的有符号数的取值范围是从 -2(n-1) 到 2(n-1)-1。无符号整数的所有 bit 位都用于表示非负数，取值范围是 0 到 2n-1。
> 3. 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38。
> 4. 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308。
> 5. float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。
> 6. 浮点数在声明的时候可以只写整数部分或者小数部分。

```go
/*测试注意*/
	fmt.Println("========================================")
	fmt.Println(math.MaxFloat32) //3.4028234663852886e+38
	fmt.Println(math.MaxFloat64) //1.7976931348623157e+308
	fmt.Println(math.MaxInt8) //127
	fmt.Println(math.MaxInt16) //32767
	fmt.Println(math.MaxInt32) //2147483647
	fmt.Println(math.MaxInt64) //9223372036854775807
	fmt.Println(math.MaxUint8) //255
	fmt.Println(math.MaxUint16) //65535
	fmt.Println(math.MaxUint32) //4294967295
	var maxuint64 uint64= math.MaxUint64
	fmt.Println(maxuint64)  // 18446744073709551615
	//fmt.Println(math.MaxUint64) //错误： constant 18446744073709551615 overflows int，   https://stackoverflow.com/questions/16474594/how-can-i-print-out-an-constant-uint64-in-go-using-fmt
	//报这个错的原因：常量本身是无类型的，常量的类型依赖于其上下文语义，在fmt.Println()时，常量被用作interface{}，因此编译器无法知道您要使用哪种具体类型。  ？？被用作interface？？
	//对于整型常量，在fmt.Println()时，默认为int. 而常量溢出了int的范围（此处int与int64位宽相同），产生编译错误，通过传递uint64（num），可以通知编译器您希望将该值视为uint64。
	fmt.Println(uint64(math.MaxUint64))  // 18446744073709551615
	//fmt.Println()输出时是以int格式进行输出的 ???
const e = .71828 // 0.71828
const f = 1.     // 1
```

> 7. 很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分

```go
const P = 1.3e5
fmt.Println(P) //130000

const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数

fmt.Println(Avogadro) // 6.02214129e+23
fmt.Println(Planck)	 //6.62606957e-34
```



## 3.2 派生类型

> - 指针类型（Pointer）
> - 数组类型
> - 结构化类型(struct)
> - Channel 类型
> - 函数类型
> - 切片类型
> - 接口类型（interface）
> - Map 类型

## 3.3 关键字

### 3.3.1  25个关键字或保留字

break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var

### 3.3.2  36 个预定义标识符

append bool byte cap close complex complex64 complex128 uint16
copy false float32 float64 imag int int8 int16 uint32
int32 int64 iota len make new nil panic uint64
print println real recover string true uint uint8 uintptr

### 3.3.3 额外知识点

- 程序一般由关键字、常量、变量、运算符、类型和函数组成。
- 程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。
- 程序中可能会使用到这些标点符号：.、,、;、: 和 …  

## 3.4 标识符

标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~ Z和a~ z)数字(0~9)、下划线“_”组成的序列，但是第一个字符必须是字母或下划线而不能是数字。

# 4. 变量

> 变量，计算机语言能存储计算结果或表示值的抽象概念。可以通过变量名访问，变量名由字母、数字、下划线组成，其中首个字符不能为数字。

- 变量声明一般形式

```go
//格式
var identifier type  // var 标识符 类型
var identifier1, identifier2 type  //var 标识符1, 标识符2 type
```

```go
var identifier int = 100
var identifier1,identifier2 int = 200,300
fmt.Println(identifier+identifier1+identifier2) //600
```

## 4.1 变量声明的四种方式

1. **指定变量类型，如果没有初始化，则变量默认为零值。**

   > - 数值类型（包括complex64/128）为 **0**
   > - 布尔类型为 **false**
   > - 字符串为 **""**（空字符串）

```go
//格式
var name type
name = value
```

```go
// 没有初始化就为零值
var b int
fmt.Println(b) //0

// bool 零值为 false
var c bool
fmt.Println(c) //false

//string默认为""
var d string
fmt.Println(d)
```

```go
//以下几种类型为 nil：
var a *int   //<nil>
var a []int 
var a map[string] int
var a chan int
var a func(string) int
var a error // error 是接口
```

2. **可根据值自行判断类型**

```go
// 声明一个变量并初始化
var a = "RUNOOB"  //可根据值自行判断类型
fmt.Println(a)  //RUNOOB
```

3. **省略 var，使用 :=来进行高效快速声明变量**

> := 的左侧必须**有**新的变量

```go
//格式
newname := value
```

```go
var intVal int 
intVal :=1 // 这时候会产生编译错误,因为intVal不是新的变量
intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句
```

```go
f := "Runoob" // var f string = "Runoob"   简写
fmt.Println(f) //Runoob
```

4. **多变量声明**

```go
//类型相同多个变量, 非全局变量   以下格式均独立
var vname1, vname2, vname3 type
vname1, vname2, vname3 = v1, v2, v3

var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断


// 这种因式分解关键字的写法一般用于声明全局变量
var (
    vname1 v_type1
    vname2 v_type2
)
```

```go
package main

var x, y int
var (  // 这种因式分解关键字的写法一般用于声明全局变量
    a int
    b bool
)

//可以自动匹配默认类别
var c, d int = 1, 2
var e, f = 123, "hello"

//这种不带声明格式的只能在函数体中出现
//g, h := 123, "hello"

func main(){
    g, h := 123, "hello"
    println(x, y, a, b, c, d, e, f, g, h) //0 0 0 false 1 2 123 hello 123 hello
}
```

## 4.2 注意

1. "：=" 赋值操作符,高效创建新变量，初始化声明：a := 50 或 b := false，a 和 b 的类型（int 和 bool）将由编译器自动推断。
2.   :=  是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。
3. 在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，但可以赋值；
4. 声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误
5. 全局变量可以声明但不用。
6. _ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

```go
//空白标识符在函数返回值时的使用：
func main() {
  _,numb,strs := numbers() //只获取函数返回值的后两个
  fmt.Println(numb,strs)
}

//一个可以返回多个值的函数
func numbers()(int,int,string){
  a , b , c := 1 , 2 , "str"
  return a,b,c
}
```



# 5. 常量

> 常量是一个简单值的标识符，在程序运行时，不会被修改的量。数据类型只可以是**布尔型、数字型（整数型、浮点型和复数）和字符串型**。
>
> 可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。

- **常量的定义格式**

```go
const identifier [type] = value

const b string = "abc" //显式类型定义：
const b = "abc" //隐式类型定义：
```

- **多个相同类型的声明**

```go
const c_name1, c_name2 = value1, value2
```

```go
//常用于枚举
const (
    //数字 0、1 和 2 分别代表未知性别、女性和男性。
    Unknown = 0
    Female = 1
    Male = 2
) 
```

```go
const(
	he = 100
	ha = 200
	xi  //此时xi与ha等值 
)
fmt.Println(he,ha,xi) //100 200 200
```

- **常量的特性**

> 可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：

```go
package main

import "unsafe"
const (
    a = "abc"
    b = len(a)
    c = unsafe.Sizeof(a)
)

func main(){
    println(a, b, c)  //abc 3 16
}
```

> **字符串类型的 unsafe.Sizeof() 为什么一直是16？**
>
> ​       实际上字符串类型对应一个结构体，该结构体有两个域，第一个域是指向该字符串的指针，第二个域是字符串的长度，每个域占8个字节，但是并不包含指针指向的字符串的内容，这也就是为什么sizeof始终返回的是16。

- **特殊常量 iota**

> **iota**，特殊常量，**行索引常量**，可认为是可以被编译器修改的常量。在 const关键字中第一次出现时将被重置为 0(const 内部的第一行之前)，**之后const 中每新增一行常量声明将使 iota 计数一次。**其常被用于枚举值。

```go
const (
    a = 5
    b = iota
    c 
)

fmt.Println(a,b,c)  //5 1 2
```

```go
const (
    a = iota   //0
    b          //1
    c          //2
    d = "ha"   //独立值，iota += 1
    e          //"ha"   iota += 1
    f = 100    //iota +=1
    g          //100  iota +=1
    h = iota   //7,恢复计数
    i          //8
)
fmt.Println(a,b,c,d,e,f,g,h,i)  // 0 1 2 ha ha 100 100 7 8
```

```go
const ( //  <<n==*(2^n)   左移几位，即为结果 乘 2的n次
    i=1<<iota  // i=1：左移 0 位,不变仍为 1;
    j=3<<iota  // j=3：左移 1 位,变为二进制 110, 即 6;
    k          // k=3：左移 2 位,变为二进制 1100, 即 12;
    l          // l=3：左移 3 位,变为二进制 11000,即 24。
)

func main() {
    fmt.Println("i=",i)  //1
    fmt.Println("j=",j)  //6
    fmt.Println("k=",k)  //12
    fmt.Println("l=",l)  //24
}
```



# 6. 枚举

> 枚举，将变量的值一一列举出来，变量只限于列举出来的值的范围内取值。Go语言中没有枚举这种数据类型的，但是可以使用const配合iota模式来实现

### 6.1.1 普通枚举

```go
const (
	a = 0
	b = 1
	c = 2
	d = 3
)

```

### 6.1.2 自增枚举

```go
const (
	a = iota  //0  默认开始值是0，
	b		  //1
	c         //2
)
const (
	e, f = iota, iota //e=0, f=0    默认开始值是0，const中每增加一行加1,同行值相同
	g    = iota       //g=1
)

const (
    a = iota    //0     //若中间中断iota，必须显式恢复。
    b           //1     //即使不恢复，iota值也会默认在改变
    c = 100     //100
    d           //100
    e = iota    //4
)
```

